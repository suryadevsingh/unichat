{"ast":null,"code":"var _createForOfIteratorHelper = require(\"D:\\\\Web\\\\unichat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar he = require('he');\n\nvar _require = require('./helper'),\n    get = _require.get,\n    numberToLetterSequence = _require.numberToLetterSequence,\n    numberToRoman = _require.numberToRoman,\n    splitClassesAndIds = _require.splitClassesAndIds,\n    trimCharacter = _require.trimCharacter; // eslint-disable-next-line import/no-unassigned-import\n\n\nrequire('./typedefs');\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatSkip(elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatInline(elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatBlock(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n}\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatLineBreak(elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n/**\n * Process a `wbk` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatWbr(elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatHorizontalLine(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatParagraph(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatPre(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatHeading(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(function (str) {\n      return str.toUpperCase();\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatBlockquote(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: function blockTransform(str) {\n      return (formatOptions.trimEmptyLines !== false ? trimCharacter(str, '\\n') : str).split('\\n').map(function (line) {\n        return '> ' + line;\n      }).join('\\n');\n    }\n  });\n}\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatImage(elem, walk, builder, formatOptions) {\n  var attribs = elem.attribs || {};\n  var alt = attribs.alt ? he.decode(attribs.alt, builder.options.decodeOptions) : '';\n  var src = !attribs.src ? '' : formatOptions.baseUrl && attribs.src.indexOf('/') === 0 ? formatOptions.baseUrl + attribs.src : attribs.src;\n  var text = !src ? alt : !alt ? '[' + src + ']' : alt + ' [' + src + ']';\n  builder.addInline(text);\n}\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatAnchor(elem, walk, builder, formatOptions) {\n  function getHref() {\n    if (formatOptions.ignoreHref) {\n      return '';\n    }\n\n    if (!elem.attribs || !elem.attribs.href) {\n      return '';\n    }\n\n    var href = elem.attribs.href.replace(/^mailto:/, '');\n\n    if (formatOptions.noAnchorUrl && href[0] === '#') {\n      return '';\n    }\n\n    href = formatOptions.baseUrl && href[0] === '/' ? formatOptions.baseUrl + href : href;\n    return he.decode(href, builder.options.decodeOptions);\n  }\n\n  var href = getHref();\n\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    var text = '';\n    builder.pushWordTransform(function (str) {\n      if (str) {\n        text += str;\n      }\n\n      return str;\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n    var hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n\n    if (!hideSameLink) {\n      builder.addInline(!text ? href : formatOptions.noLinkBrackets ? ' ' + href : ' [' + href + ']', {\n        noWordTransform: true\n      });\n    }\n  }\n}\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns inreasing index each time it is called.\n */\n\n\nfunction formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n  var isNestedList = get(elem, ['parent', 'name']) === 'li'; // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n\n  var maxPrefixLength = 0;\n  var listItems = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !/^\\s*$/.test(child.data);\n  }).map(function (child) {\n    if (child.name !== 'li') {\n      return {\n        node: child,\n        prefix: ''\n      };\n    }\n\n    var prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n\n    if (prefix.length > maxPrefixLength) {\n      maxPrefixLength = prefix.length;\n    }\n\n    return {\n      node: child,\n      prefix: prefix\n    };\n  });\n\n  if (!listItems.length) {\n    return;\n  }\n\n  var reservedLineLength = maxPrefixLength;\n  var spacing = '\\n' + ' '.repeat(reservedLineLength);\n  builder.openBlock({\n    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2\n  });\n\n  var _iterator = _createForOfIteratorHelper(listItems),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var _step$value = _step.value,\n          node = _step$value.node,\n          prefix = _step$value.prefix;\n      builder.openBlock({\n        leadingLineBreaks: 1,\n        reservedLineLength: reservedLineLength\n      });\n      walk([node], builder);\n      builder.closeBlock({\n        trailingLineBreaks: 1,\n        blockTransform: function blockTransform(str) {\n          return prefix + ' '.repeat(reservedLineLength - prefix.length) + str.replace(/\\n/g, spacing);\n        }\n      });\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  builder.closeBlock({\n    trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n  });\n}\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatUnorderedList(elem, walk, builder, formatOptions) {\n  var prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, function () {\n    return prefix;\n  });\n}\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatOrderedList(elem, walk, builder, formatOptions) {\n  var nextIndex = Number(elem.attribs.start || '1');\n  var indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n\n  var nextPrefixCallback = function nextPrefixCallback() {\n    return ' ' + indexFunction(nextIndex++) + '. ';\n  };\n\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\n\n\nfunction getOrderedListIndexFunction() {\n  var olType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '1';\n\n  switch (olType) {\n    case 'a':\n      return function (i) {\n        return numberToLetterSequence(i, 'a');\n      };\n\n    case 'A':\n      return function (i) {\n        return numberToLetterSequence(i, 'A');\n      };\n\n    case 'i':\n      return function (i) {\n        return numberToRoman(i).toLowerCase();\n      };\n\n    case 'I':\n      return function (i) {\n        return numberToRoman(i);\n      };\n\n    case '1':\n    default:\n      return function (i) {\n        return i.toString();\n      };\n  }\n}\n\nfunction isDataTable(attr, tables) {\n  if (tables === true) {\n    return true;\n  }\n\n  if (!attr) {\n    return false;\n  }\n\n  var _splitClassesAndIds = splitClassesAndIds(tables),\n      classes = _splitClassesAndIds.classes,\n      ids = _splitClassesAndIds.ids;\n\n  var attrClasses = (attr['class'] || '').split(' ');\n  var attrIds = (attr['id'] || '').split(' ');\n  return attrClasses.some(function (x) {\n    return classes.includes(x);\n  }) || attrIds.some(function (x) {\n    return ids.includes(x);\n  });\n}\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatTable(elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\n\n\nfunction formatDataTable(elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    colSpacing: formatOptions.colSpacing,\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    rowSpacing: formatOptions.rowSpacing,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n\n  function formatCell(cellNode) {\n    var colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    var rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({\n      maxColumnWidth: formatOptions.maxColumnWidth\n    });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({\n      colspan: colspan,\n      rowspan: rowspan\n    });\n  }\n\n  function walkTable(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n\n    var formatHeaderCell = formatOptions.uppercaseHeaderCells ? function (cellNode) {\n      builder.pushWordTransform(function (str) {\n        return str.toUpperCase();\n      });\n      formatCell(cellNode);\n      builder.popWordTransform();\n    } : formatCell;\n\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n\n      case 'tr':\n        {\n          builder.openTableRow();\n\n          var _iterator2 = _createForOfIteratorHelper(elem.children),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var childOfTr = _step2.value;\n\n              if (childOfTr.type !== 'tag') {\n                continue;\n              }\n\n              switch (childOfTr.name) {\n                case 'th':\n                  {\n                    formatHeaderCell(childOfTr);\n                    break;\n                  }\n\n                case 'td':\n                  {\n                    formatCell(childOfTr);\n                    break;\n                  }\n\n                default: // do nothing\n\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          builder.closeTableRow();\n          break;\n        }\n\n      default: // do nothing\n\n    }\n  }\n}\n\nmodule.exports = {\n  anchor: formatAnchor,\n  block: formatBlock,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  inline: formatInline,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  skip: formatSkip,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n};","map":{"version":3,"sources":["D:/Web/unichat/node_modules/html-to-text/lib/formatter.js"],"names":["he","require","get","numberToLetterSequence","numberToRoman","splitClassesAndIds","trimCharacter","formatSkip","elem","walk","builder","formatOptions","formatInline","children","formatBlock","openBlock","leadingLineBreaks","closeBlock","trailingLineBreaks","formatLineBreak","addLineBreak","formatWbr","addWordBreakOpportunity","formatHorizontalLine","addInline","repeat","length","options","wordwrap","formatParagraph","formatPre","isPre","formatHeading","uppercase","pushWordTransform","str","toUpperCase","popWordTransform","formatBlockquote","reservedLineLength","blockTransform","trimEmptyLines","split","map","line","join","formatImage","attribs","alt","decode","decodeOptions","src","baseUrl","indexOf","text","formatAnchor","getHref","ignoreHref","href","replace","noAnchorUrl","hideSameLink","hideLinkHrefIfSameAsText","noLinkBrackets","noWordTransform","formatList","nextPrefixCallback","isNestedList","maxPrefixLength","listItems","filter","child","type","test","data","name","node","prefix","trimStart","spacing","formatUnorderedList","itemPrefix","formatOrderedList","nextIndex","Number","start","indexFunction","getOrderedListIndexFunction","olType","i","toLowerCase","toString","isDataTable","attr","tables","classes","ids","attrClasses","attrIds","some","x","includes","formatTable","formatDataTable","openTable","forEach","walkTable","closeTable","colSpacing","rowSpacing","formatCell","cellNode","colspan","rowspan","openTableCell","maxColumnWidth","closeTableCell","formatHeaderCell","uppercaseHeaderCells","openTableRow","childOfTr","closeTableRow","module","exports","anchor","block","blockquote","dataTable","heading","horizontalLine","image","inline","lineBreak","orderedList","paragraph","pre","skip","table","unorderedList","wbr"],"mappings":"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","sourcesContent":["const he = require('he');\n\nconst { get, numberToLetterSequence, numberToRoman, splitClassesAndIds, trimCharacter } = require('./helper');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip (elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline (elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak (elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbk` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr (elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\\n') : str)\n      .split('\\n')\n      .map(line => '> ' + line)\n      .join('\\n')\n  });\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage (elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = (attribs.alt)\n    ? he.decode(attribs.alt, builder.options.decodeOptions)\n    : '';\n  const src = (!attribs.src)\n    ? ''\n    : (formatOptions.baseUrl && attribs.src.indexOf('/') === 0)\n      ? formatOptions.baseUrl + attribs.src\n      : attribs.src;\n  const text = (!src)\n    ? alt\n    : (!alt)\n      ? '[' + src + ']'\n      : alt + ' [' + src + ']';\n\n  builder.addInline(text);\n}\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor (elem, walk, builder, formatOptions) {\n  function getHref () {\n    if (formatOptions.ignoreHref) { return ''; }\n    if (!elem.attribs || !elem.attribs.href) { return ''; }\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }\n    href = (formatOptions.baseUrl && href[0] === '/')\n      ? formatOptions.baseUrl + href\n      : href;\n    return he.decode(href, builder.options.decodeOptions);\n  }\n  const href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(\n      str => {\n        if (str) { text += str; }\n        return str;\n      }\n    );\n    walk(elem.children, builder);\n    builder.popWordTransform();\n\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(\n        (!text)\n          ? href\n          : (formatOptions.noLinkBrackets)\n            ? ' ' + href\n            : ' [' + href + ']',\n        { noWordTransform: true }\n      );\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns inreasing index each time it is called.\n */\nfunction formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || [])\n    // it might be more accuurate to check only for html spaces here, but no significant benefit\n    .filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data))\n    .map(function (child) {\n      if (child.name !== 'li') {\n        return { node: child, prefix: '' };\n      }\n      const prefix = (isNestedList)\n        ? nextPrefixCallback().trimStart()\n        : nextPrefixCallback();\n      if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }\n      return { node: child, prefix: prefix };\n    });\n  if (!listItems.length) { return; }\n\n  const reservedLineLength = maxPrefixLength;\n  const spacing = '\\n' + ' '.repeat(reservedLineLength);\n  builder.openBlock({ leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2) });\n  for (const { node, prefix } of listItems) {\n    builder.openBlock({\n      leadingLineBreaks: 1,\n      reservedLineLength: reservedLineLength\n    });\n    walk([node], builder);\n    builder.closeBlock({\n      trailingLineBreaks: 1,\n      blockTransform: str => prefix + ' '.repeat(reservedLineLength - prefix.length) + str.replace(/\\n/g, spacing)\n    });\n  }\n  builder.closeBlock({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList (elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList (elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction (olType = '1') {\n  switch (olType) {\n    case 'a': return (i) => numberToLetterSequence(i, 'a');\n    case 'A': return (i) => numberToLetterSequence(i, 'A');\n    case 'i': return (i) => numberToRoman(i).toLowerCase();\n    case 'I': return (i) => numberToRoman(i);\n    case '1':\n    default: return (i) => (i).toString();\n  }\n}\n\nfunction isDataTable (attr, tables) {\n  if (tables === true) { return true; }\n  if (!attr) { return false; }\n\n  const { classes, ids } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable (elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables)\n    ? formatDataTable(elem, walk, builder, formatOptions)\n    : formatBlock(elem, walk, builder, formatOptions);\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable (elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    colSpacing: formatOptions.colSpacing,\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    rowSpacing: formatOptions.rowSpacing,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n\n  function formatCell (cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({ colspan: colspan, rowspan: rowspan });\n  }\n\n  function walkTable (elem) {\n    if (elem.type !== 'tag') { return; }\n\n    const formatHeaderCell = (formatOptions.uppercaseHeaderCells)\n      ? (cellNode) => {\n        builder.pushWordTransform(str => str.toUpperCase());\n        formatCell(cellNode);\n        builder.popWordTransform();\n      }\n      : formatCell;\n\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n\n      case 'tr': {\n        builder.openTableRow();\n        for (const childOfTr of elem.children) {\n          if (childOfTr.type !== 'tag') { continue; }\n          switch (childOfTr.name) {\n            case 'th': {\n              formatHeaderCell(childOfTr);\n              break;\n            }\n            case 'td': {\n              formatCell(childOfTr);\n              break;\n            }\n            default:\n              // do nothing\n          }\n        }\n        builder.closeTableRow();\n        break;\n      }\n\n      default:\n        // do nothing\n    }\n  }\n}\n\nmodule.exports = {\n  anchor: formatAnchor,\n  block: formatBlock,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  inline: formatInline,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  skip: formatSkip,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n};\n"]},"metadata":{},"sourceType":"script"}
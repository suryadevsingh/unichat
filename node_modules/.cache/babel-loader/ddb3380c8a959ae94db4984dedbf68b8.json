{"ast":null,"code":"var _classCallCheck = require(\"D:\\\\Web\\\\unichat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\Web\\\\unichat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _require = require('./helper'),\n    trimCharacter = _require.trimCharacter; // eslint-disable-next-line no-unused-vars\n\n\nvar _require2 = require('./stack-item'),\n    StackItem = _require2.StackItem,\n    BlockStackItem = _require2.BlockStackItem,\n    TableCellStackItem = _require2.TableCellStackItem,\n    TableRowStackItem = _require2.TableRowStackItem,\n    TableStackItem = _require2.TableStackItem,\n    TransformerStackItem = _require2.TransformerStackItem;\n\nvar _require3 = require('./table-printer'),\n    tableToString = _require3.tableToString;\n\nvar _require4 = require('./whitespace-processor'),\n    WhitespaceProcessor = _require4.WhitespaceProcessor; // eslint-disable-next-line import/no-unassigned-import\n\n\nrequire('./typedefs');\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\n\n\nvar BlockTextBuilder = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   */\n  function BlockTextBuilder(options) {\n    _classCallCheck(this, BlockTextBuilder);\n\n    this.options = options;\n    this.whitepaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n\n    this._wordTransformer = undefined;\n  }\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n\n\n  _createClass(BlockTextBuilder, [{\n    key: \"pushWordTransform\",\n    value: function pushWordTransform(wordTransform) {\n      this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n    }\n    /**\n     * Remove a function from the word transformations stack.\n     *\n     * @returns { (str: string) => string } A function that was removed.\n     */\n\n  }, {\n    key: \"popWordTransform\",\n    value: function popWordTransform() {\n      if (!this._wordTransformer) {\n        return undefined;\n      }\n\n      var transform = this._wordTransformer.transform;\n      this._wordTransformer = this._wordTransformer.next;\n      return transform;\n    }\n    /** @returns { (str: string) => string } */\n\n  }, {\n    key: \"_getCombinedWordTransformer\",\n    value: function _getCombinedWordTransformer() {\n      var _this = this;\n\n      var applyTransformer = function applyTransformer(str, transformer) {\n        return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n      };\n\n      return function (str) {\n        return applyTransformer(str, _this._wordTransformer);\n      };\n    }\n  }, {\n    key: \"_popStackItem\",\n    value: function _popStackItem() {\n      var item = this._stackItem;\n      this._stackItem = item.next;\n      return item;\n    }\n    /**\n     * Add a line break into currently built block.\n     */\n\n  }, {\n    key: \"addLineBreak\",\n    value: function addLineBreak() {\n      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n        return;\n      }\n\n      if (this._stackItem.isPre) {\n        this._stackItem.rawText += '\\n';\n      } else {\n        this._stackItem.inlineTextBuilder.startNewLine();\n      }\n    }\n    /**\n     * Allow to break line in case directly following text will not fit.\n     */\n\n  }, {\n    key: \"addWordBreakOpportunity\",\n    value: function addWordBreakOpportunity() {\n      if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem) {\n        this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n      }\n    }\n    /**\n     * Add a node inline into the currently built block.\n     *\n     * @param { string } str\n     * Text content of a node to add.\n     *\n     * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n     * Object holding the parameters of the operation.\n     *\n     * Boolean value is deprecated.\n     *\n     * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n     * Ignore word transformers if there are any.\n     */\n\n  }, {\n    key: \"addInline\",\n    value: function addInline(str) {\n      var optionsObjectOrNoWordTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (typeof optionsObjectOrNoWordTransform === 'object') {\n        this._addInline(str, optionsObjectOrNoWordTransform);\n      } else {\n        this._addInline(str, {\n          noWordTransform: optionsObjectOrNoWordTransform\n        });\n      }\n    }\n  }, {\n    key: \"_addInline\",\n    value: function _addInline(str) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$noWordTransform = _ref.noWordTransform,\n          noWordTransform = _ref$noWordTransform === void 0 ? false : _ref$noWordTransform;\n\n      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n        return;\n      }\n\n      if (this._stackItem.isPre) {\n        this._stackItem.rawText += str;\n        return;\n      }\n\n      if (this.whitepaceProcessor.testContainsWords(str) || str.length && !this._stackItem.stashedLineBreaks // or at least spaces to take into account.\n      ) {\n        if (this._stackItem.stashedLineBreaks) {\n          this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n\n        this.whitepaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, this._wordTransformer && !noWordTransform ? this._getCombinedWordTransformer() : undefined);\n        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n      }\n    }\n    /**\n     * Start building a new block.\n     *\n     * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n     * Object holding the parameters of the block.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n     * This block should have at least this number of line breaks to separate if from any preceding block.\n     *\n     * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n     * Reserve this number of characters on each line for block markup.\n     *\n     * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n     * Should HTML whitespace be preserved inside this block.\n     *\n     * @param { number }  [reservedLineLength]\n     * Deprecated.\n     *\n     * @param { boolean } [isPre]\n     * Deprecated.\n     */\n\n  }, {\n    key: \"openBlock\",\n    value: function openBlock() {\n      var optionsObjectOrLeadingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var reservedLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var isPre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n        this._openBlock(optionsObjectOrLeadingLineBreaks);\n      } else {\n        this._openBlock({\n          isPre: isPre,\n          leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n          reservedLineLength: reservedLineLength\n        });\n      }\n    }\n  }, {\n    key: \"_openBlock\",\n    value: function _openBlock() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$leadingLineBrea = _ref2.leadingLineBreaks,\n          leadingLineBreaks = _ref2$leadingLineBrea === void 0 ? 1 : _ref2$leadingLineBrea,\n          _ref2$reservedLineLen = _ref2.reservedLineLength,\n          reservedLineLength = _ref2$reservedLineLen === void 0 ? 0 : _ref2$reservedLineLen,\n          _ref2$isPre = _ref2.isPre,\n          isPre = _ref2$isPre === void 0 ? false : _ref2$isPre;\n\n      var maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n      this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n\n      if (isPre) {\n        this._stackItem.isPre = true;\n      }\n    }\n    /**\n     * Finalize currently built block, add it's content to the parent block.\n     *\n     * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n     * Object holding the parameters of the block.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n     * This block should have at least this number of line breaks to separate it from any following block.\n     *\n     * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n     * A function to transform the block text before adding to the parent block.\n     * This happens after word wrap and should be used in combination with reserved line length\n     * in order to keep line lengths correct.\n     * Used for whole block markup.\n     *\n     * @param { (str: string) => string } [blockTransform]\n     * Deprecated.\n     */\n\n  }, {\n    key: \"closeBlock\",\n    value: function closeBlock() {\n      var optionsObjectOrTrailingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var blockTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n      if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n        this._closeBlock(optionsObjectOrTrailingLineBreaks);\n      } else {\n        this._closeBlock({\n          trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n          blockTransform: blockTransform\n        });\n      }\n    }\n  }, {\n    key: \"_closeBlock\",\n    value: function _closeBlock() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$trailingLineBre = _ref3.trailingLineBreaks,\n          trailingLineBreaks = _ref3$trailingLineBre === void 0 ? 1 : _ref3$trailingLineBre,\n          _ref3$blockTransform = _ref3.blockTransform,\n          blockTransform = _ref3$blockTransform === void 0 ? undefined : _ref3$blockTransform;\n\n      var block = this._popStackItem();\n\n      var blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n      addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n    }\n    /**\n     * Start building a table.\n     */\n\n  }, {\n    key: \"openTable\",\n    value: function openTable() {\n      this._stackItem = new TableStackItem(this._stackItem);\n    }\n    /**\n     * Start building a table row.\n     */\n\n  }, {\n    key: \"openTableRow\",\n    value: function openTableRow() {\n      if (!(this._stackItem instanceof TableStackItem)) {\n        throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n      }\n\n      this._stackItem = new TableRowStackItem(this._stackItem);\n    }\n    /**\n     * Start building a table cell.\n     *\n     * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n     * Object holding the parameters of the cell.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n     * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n     */\n\n  }, {\n    key: \"openTableCell\",\n    value: function openTableCell() {\n      var optionsObjectOrMaxColumnWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n        this._openTableCell(optionsObjectOrMaxColumnWidth);\n      } else {\n        this._openTableCell({\n          maxColumnWidth: optionsObjectOrMaxColumnWidth\n        });\n      }\n    }\n  }, {\n    key: \"_openTableCell\",\n    value: function _openTableCell() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$maxColumnWidth = _ref4.maxColumnWidth,\n          maxColumnWidth = _ref4$maxColumnWidth === void 0 ? undefined : _ref4$maxColumnWidth;\n\n      if (!(this._stackItem instanceof TableRowStackItem)) {\n        throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n      }\n\n      this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n    }\n    /**\n     * Finalize currently built table cell and add it to parent table row's cells.\n     *\n     * @param { object | number } [optionsObjectOrColspan]\n     * Object holding the parameters of the cell.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n     * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n     *\n     * @param { number } [rowspan] Deprecated.\n     */\n\n  }, {\n    key: \"closeTableCell\",\n    value: function closeTableCell() {\n      var optionsObjectOrColspan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rowspan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n      if (typeof optionsObjectOrColspan === 'object') {\n        this._closeTableCell(optionsObjectOrColspan);\n      } else {\n        this._closeTableCell({\n          colspan: optionsObjectOrColspan,\n          rowspan: rowspan\n        });\n      }\n    }\n  }, {\n    key: \"_closeTableCell\",\n    value: function _closeTableCell() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref5$colspan = _ref5.colspan,\n          colspan = _ref5$colspan === void 0 ? 1 : _ref5$colspan,\n          _ref5$rowspan = _ref5.rowspan,\n          rowspan = _ref5$rowspan === void 0 ? 1 : _ref5$rowspan;\n\n      var cell = this._popStackItem();\n\n      var text = trimCharacter(getText(cell), '\\n');\n      cell.next.cells.push({\n        colspan: colspan,\n        rowspan: rowspan,\n        text: text\n      });\n    }\n    /**\n     * Finalize currently built table row and add it to parent table's rows.\n     */\n\n  }, {\n    key: \"closeTableRow\",\n    value: function closeTableRow() {\n      var row = this._popStackItem();\n\n      row.next.rows.push(row.cells);\n    }\n    /**\n     * Finalize currently built table and add the rendered text to the parent block.\n     *\n     * @param { object | number } [optionsObjectOrColSpacing]\n     * Object holding the parameters of the table.\n     *\n     * Number value is depreceted.\n     *\n     * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n     * Number of spaces between table columns.\n     *\n     * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n     * Number of empty lines between table rows.\n     *\n     * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n     * This table should have at least this number of line breaks to separate if from any preceding block.\n     *\n     * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n     * This table should have at least this number of line breaks to separate it from any following block.\n     *\n     * @param { number } [rowSpacing]\n     * Deprecated.\n     *\n     * @param { number } [leadingLineBreaks]\n     * Deprecated.\n     *\n     * @param { number } [trailingLineBreaks]\n     * Deprecated.\n     */\n\n  }, {\n    key: \"closeTable\",\n    value: function closeTable() {\n      var optionsObjectOrColSpacing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rowSpacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var leadingLineBreaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var trailingLineBreaks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n      if (typeof optionsObjectOrColSpacing === 'object') {\n        this._closeTable(optionsObjectOrColSpacing);\n      } else {\n        this._closeTable({\n          colSpacing: optionsObjectOrColSpacing,\n          leadingLineBreaks: leadingLineBreaks,\n          rowSpacing: rowSpacing,\n          trailingLineBreaks: trailingLineBreaks\n        });\n      }\n    }\n  }, {\n    key: \"_closeTable\",\n    value: function _closeTable() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$colSpacing = _ref6.colSpacing,\n          colSpacing = _ref6$colSpacing === void 0 ? 3 : _ref6$colSpacing,\n          _ref6$rowSpacing = _ref6.rowSpacing,\n          rowSpacing = _ref6$rowSpacing === void 0 ? 0 : _ref6$rowSpacing,\n          _ref6$leadingLineBrea = _ref6.leadingLineBreaks,\n          leadingLineBreaks = _ref6$leadingLineBrea === void 0 ? 2 : _ref6$leadingLineBrea,\n          _ref6$trailingLineBre = _ref6.trailingLineBreaks,\n          trailingLineBreaks = _ref6$trailingLineBre === void 0 ? 2 : _ref6$trailingLineBre;\n\n      var table = this._popStackItem();\n\n      var output = tableToString(table.rows, rowSpacing, colSpacing);\n\n      if (output) {\n        addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n      }\n    }\n    /**\n     * Return the rendered text content of this builder.\n     *\n     * @returns { string }\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return getText(this._stackItem.getRoot()); // There should only be the root item if everything is closed properly.\n    }\n  }]);\n\n  return BlockTextBuilder;\n}();\n\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n\n  var parentText = getText(stackItem);\n  var lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\nmodule.exports = {\n  BlockTextBuilder: BlockTextBuilder\n};","map":{"version":3,"sources":["D:/Web/unichat/node_modules/html-to-text/lib/block-text-builder.js"],"names":["require","trimCharacter","StackItem","BlockStackItem","TableCellStackItem","TableRowStackItem","TableStackItem","TransformerStackItem","tableToString","WhitespaceProcessor","BlockTextBuilder","options","whitepaceProcessor","_stackItem","_wordTransformer","undefined","wordTransform","transform","next","applyTransformer","str","transformer","item","isPre","rawText","inlineTextBuilder","startNewLine","wordBreakOpportunity","optionsObjectOrNoWordTransform","_addInline","noWordTransform","testContainsWords","length","stashedLineBreaks","shrinkWrapAdd","_getCombinedWordTransformer","optionsObjectOrLeadingLineBreaks","reservedLineLength","_openBlock","leadingLineBreaks","maxLineLength","Math","max","optionsObjectOrTrailingLineBreaks","blockTransform","_closeBlock","trailingLineBreaks","block","_popStackItem","blockText","getText","addText","Error","optionsObjectOrMaxColumnWidth","_openTableCell","maxColumnWidth","optionsObjectOrColspan","rowspan","_closeTableCell","colspan","cell","text","cells","push","row","rows","optionsObjectOrColSpacing","rowSpacing","_closeTable","colSpacing","table","output","getRoot","stackItem","isEmpty","toString","parentText","lineBreaks","clear","repeat","module","exports"],"mappings":"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","sourcesContent":["\nconst { trimCharacter } = require('./helper');\n// eslint-disable-next-line no-unused-vars\nconst { StackItem, BlockStackItem, TableCellStackItem, TableRowStackItem, TableStackItem, TransformerStackItem }\n  = require('./stack-item');\nconst { tableToString } = require('./table-printer');\nconst { WhitespaceProcessor } = require('./whitespace-processor');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   */\n  constructor (options) {\n    this.options = options;\n    this.whitepaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform (wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform () {\n    if (!this._wordTransformer) { return undefined; }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer () {\n    const applyTransformer = (str, transformer) =>\n      ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);\n    return (str) => applyTransformer(str, this._wordTransformer);\n  }\n\n  _popStackItem () {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak () {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity () {\n    if (\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    ) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n   * Object holding the parameters of the operation.\n   *\n   * Boolean value is deprecated.\n   *\n   * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n   * Ignore word transformers if there are any.\n   */\n  addInline (str, optionsObjectOrNoWordTransform = {}) {\n    if (typeof optionsObjectOrNoWordTransform === 'object') {\n      this._addInline(str, optionsObjectOrNoWordTransform);\n    } else {\n      this._addInline(str, { noWordTransform: optionsObjectOrNoWordTransform });\n    }\n  }\n\n  _addInline (str, { noWordTransform = false } = {}) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (\n      this.whitepaceProcessor.testContainsWords(str) || // There are words to add;\n      (str.length && !this._stackItem.stashedLineBreaks) // or at least spaces to take into account.\n    ) {\n      if (this._stackItem.stashedLineBreaks) {\n        this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n      }\n      this.whitepaceProcessor.shrinkWrapAdd(\n        str,\n        this._stackItem.inlineTextBuilder,\n        (this._wordTransformer && !noWordTransform) ? this._getCombinedWordTransformer() : undefined\n      );\n      this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n    }\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n   * Should HTML whitespace be preserved inside this block.\n   *\n   * @param { number }  [reservedLineLength]\n   * Deprecated.\n   *\n   * @param { boolean } [isPre]\n   * Deprecated.\n   */\n  openBlock (optionsObjectOrLeadingLineBreaks = {}, reservedLineLength = undefined, isPre = undefined) {\n    if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n      this._openBlock(optionsObjectOrLeadingLineBreaks);\n    } else {\n      this._openBlock({\n        isPre: isPre,\n        leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n        reservedLineLength: reservedLineLength,\n      });\n    }\n  }\n\n  _openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(\n      this.options,\n      this._stackItem,\n      leadingLineBreaks,\n      maxLineLength\n    );\n    if (isPre) { this._stackItem.isPre = true; }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   *\n   * @param { (str: string) => string } [blockTransform]\n   * Deprecated.\n   */\n  closeBlock (optionsObjectOrTrailingLineBreaks = {}, blockTransform = undefined) {\n    if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n      this._closeBlock(optionsObjectOrTrailingLineBreaks);\n    } else {\n      this._closeBlock({\n        trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n        blockTransform: blockTransform,\n      });\n    }\n  }\n\n  _closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n    const block = this._popStackItem();\n    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable () {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow () {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell (optionsObjectOrMaxColumnWidth = {}) {\n    if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n      this._openTableCell(optionsObjectOrMaxColumnWidth);\n    } else {\n      this._openTableCell({ maxColumnWidth: optionsObjectOrMaxColumnWidth });\n    }\n  }\n\n  _openTableCell ({ maxColumnWidth = undefined } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object | number } [optionsObjectOrColspan]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n   * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n   *\n   * @param { number } [rowspan] Deprecated.\n   */\n  closeTableCell (optionsObjectOrColspan = {}, rowspan = undefined) {\n    if (typeof optionsObjectOrColspan === 'object') {\n      this._closeTableCell(optionsObjectOrColspan);\n    } else {\n      this._closeTableCell({\n        colspan: optionsObjectOrColspan,\n        rowspan: rowspan,\n      });\n    }\n  }\n\n  _closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow () {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object | number } [optionsObjectOrColSpacing]\n   * Object holding the parameters of the table.\n   *\n   * Number value is depreceted.\n   *\n   * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n   * Number of spaces between table columns.\n   *\n   * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n   * Number of empty lines between table rows.\n   *\n   * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { number } [rowSpacing]\n   * Deprecated.\n   *\n   * @param { number } [leadingLineBreaks]\n   * Deprecated.\n   *\n   * @param { number } [trailingLineBreaks]\n   * Deprecated.\n   */\n  closeTable (\n    optionsObjectOrColSpacing = {},\n    rowSpacing = undefined,\n    leadingLineBreaks = undefined,\n    trailingLineBreaks = undefined\n  ) {\n    if (typeof optionsObjectOrColSpacing === 'object') {\n      this._closeTable(optionsObjectOrColSpacing);\n    } else {\n      this._closeTable({\n        colSpacing: optionsObjectOrColSpacing,\n        leadingLineBreaks: leadingLineBreaks,\n        rowSpacing: rowSpacing,\n        trailingLineBreaks: trailingLineBreaks\n      });\n    }\n  }\n\n  _closeTable ({ colSpacing = 3, rowSpacing = 0, leadingLineBreaks = 2, trailingLineBreaks = 2 } = {}) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows, rowSpacing, colSpacing);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText (stackItem) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n  return (stackItem.inlineTextBuilder.isEmpty())\n    ? stackItem.rawText\n    : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\nmodule.exports = { BlockTextBuilder: BlockTextBuilder };\n"]},"metadata":{},"sourceType":"script"}
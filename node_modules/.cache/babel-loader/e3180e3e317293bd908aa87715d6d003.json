{"ast":null,"code":"var _classCallCheck = require(\"D:\\\\Web\\\\unichat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\Web\\\\unichat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _toConsumableArray = require(\"D:\\\\Web\\\\unichat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\n// eslint-disable-next-line no-unused-vars\nvar _require = require('./inline-text-builder'),\n    InlineTextBuilder = _require.InlineTextBuilder; // eslint-disable-next-line import/no-unassigned-import\n\n\nrequire('./typedefs');\n\nfunction charactersToCodes(str) {\n  return _toConsumableArray(str).map(function (c) {\n    return \"\\\\u\" + c.charCodeAt(0).toString(16).padStart(4, '0');\n  }).join('');\n}\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\n\n\nvar WhitespaceProcessor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  function WhitespaceProcessor(options) {\n    _classCallCheck(this, WhitespaceProcessor);\n\n    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, '') : options.whitespaceCharacters;\n    var whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(\"^[\".concat(whitespaceCodes, \"]\"));\n    this.trailingWhitespaceRe = new RegExp(\"[\".concat(whitespaceCodes, \"]$\"));\n    this.allWhitespaceOrEmptyRe = new RegExp(\"^[\".concat(whitespaceCodes, \"]*$\"));\n\n    if (options.preserveNewlines) {\n      var wordOrNewlineRe = new RegExp(\"\\n|[^\\n\".concat(whitespaceCodes, \"]+\"), 'gm');\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       */\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        var transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (str) {\n          return str;\n        };\n\n        if (!text) {\n          return;\n        }\n\n        var previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        var anyMatch = false;\n        var m = wordOrNewlineRe.exec(text);\n\n        if (m) {\n          anyMatch = true;\n\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]));\n            }\n          }\n        }\n\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text); // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n    } else {\n      var wordRe = new RegExp(\"[^\".concat(whitespaceCodes, \"]+\"), 'g');\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        var transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (str) {\n          return str;\n        };\n\n        if (!text) {\n          return;\n        }\n\n        var previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        var anyMatch = false;\n        var m = wordRe.exec(text);\n\n        if (m) {\n          anyMatch = true;\n\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          }\n        }\n\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n      };\n    }\n  }\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n\n\n  _createClass(WhitespaceProcessor, [{\n    key: \"testLeadingWhitespace\",\n    value: function testLeadingWhitespace(text) {\n      return this.leadingWhitespaceRe.test(text);\n    }\n    /**\n     * Test whether the given text ends with HTML whitespace character.\n     *\n     * @param   { string }  text  The string to test.\n     * @returns { boolean }\n     */\n\n  }, {\n    key: \"testTrailingWhitespace\",\n    value: function testTrailingWhitespace(text) {\n      return this.trailingWhitespaceRe.test(text);\n    }\n    /**\n     * Test whether the given text contains any non-whitespace characters.\n     *\n     * @param   { string }  text  The string to test.\n     * @returns { boolean }\n     */\n\n  }, {\n    key: \"testContainsWords\",\n    value: function testContainsWords(text) {\n      return !this.allWhitespaceOrEmptyRe.test(text);\n    }\n  }]);\n\n  return WhitespaceProcessor;\n}();\n\nmodule.exports = {\n  WhitespaceProcessor: WhitespaceProcessor\n};","map":{"version":3,"sources":["D:/Web/unichat/node_modules/html-to-text/lib/whitespace-processor.js"],"names":["require","InlineTextBuilder","charactersToCodes","str","map","c","charCodeAt","toString","padStart","join","WhitespaceProcessor","options","whitespaceChars","preserveNewlines","whitespaceCharacters","replace","whitespaceCodes","leadingWhitespaceRe","RegExp","trailingWhitespaceRe","allWhitespaceOrEmptyRe","wordOrNewlineRe","shrinkWrapAdd","text","inlineTextBuilder","transform","previouslyStashedSpace","stashedSpace","anyMatch","m","exec","startNewLine","testLeadingWhitespace","pushWord","concatWord","testTrailingWhitespace","wordRe","test","module","exports"],"mappings":"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","sourcesContent":["\n// eslint-disable-next-line no-unused-vars\nconst { InlineTextBuilder } = require('./inline-text-builder');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\nfunction charactersToCodes (str) {\n  return [...str]\n    .map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))\n    .join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nclass WhitespaceProcessor {\n\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor (options) {\n    this.whitespaceChars = (options.preserveNewlines)\n      ? options.whitespaceCharacters.replace(/\\n/g, '')\n      : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n\n    if (options.preserveNewlines) {\n\n      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str)) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]));\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n\n    } else {\n\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str)) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);\n      };\n\n    }\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testLeadingWhitespace (text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testTrailingWhitespace (text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testContainsWords (text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n\n}\n\nmodule.exports = { WhitespaceProcessor: WhitespaceProcessor };\n"]},"metadata":{},"sourceType":"script"}